<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Subresource Integrity Fallback</title>
  <link rel="stylesheet" type="text/css" href="markdown.css">
</head>
<body>
  <main>
    <h1>Subresource Integrity Fallback</h1>

    <h2>What is Subresource Integrity</h2>
    <p><a href="https://mdn.io/SubresourceIntegrity">Subresource Integrity (SRI)</a> is a security feature that ensures that resources client browser downloads and runs (JavaScript/CSS) haven't been tampered with.</p>

    <p><a href="http://caniuse.com/#feat=subresource-integrity">SRI Browser support</a> is on the rise and some CDNs include it in the best practices. All is sunsh<a href="https://www.youtube.com/watch?v=XQmBXEZEYtg">i</a>ne and lollipops until you see this error in user's console:</p>

    <figure>
      <img src="sri-issue-chrome.jpg" alt="Failed Subresource Integrity check in Chrome" />
      <figcaption>Failed Subresource Integrity check in Chrome</figcaption>
    </figure>

    <p>Guess what, nothing works. Nobody knows why. Rogue proxy? Optimalization proxy? Maybe your CDN is hacked or lying to you. Anyway, your resources are broken.</p>

    <h2>Fallback</h2>
    <p>If we don't want to leave user with an application in nonfunctioning state or at least provide the user some feedback on why application couldn't start, we need a fallback. So how can we handle tampered resource?</p>

    <h3>Strategy</h3>
    <p>Script is downloaded, but before its execution, SRI hash is checked against the downloaded resource. If hash check fails, <a href="https://www.w3.org/TR/SRI/#handling-integrity-violations">error event is fired</a> and resource is not executed. This error is not propagated to the <code>window.onerror</code> and <em>afaik</em> can't be distinguished from other errors. So we need to catch all of them.</p>

    <p>To catch <code>script/link</code> errors, we can use <code>onerror</code> handler. But we need to hook it right as the resource is added to the DOM. For that we can use <a href="https://developer.mozilla.org/cs/docs/Web/API/MutationObserver">MutationObserver</a>.</p>

    <h3>Fallback flow</h3>
    <ol>
      <li>Monitor DOM for a new <code>script/link</code> elements with <code>integrity</code> attribute</li>
      <li>Add <code>onerror</code> handler to those</li>
      <li>If <code>onerror</code> is fired, try to load fallback resource specified on the element</li>
      <li>When downloading resource fails (or fallback is not available) script fires an event to notify user that something went wrong</li>
    </ol>

    <h3>Code</h3>
    <p>Following code must be placed in <code>&lt;head&gt;</code> before any resource using <code>integrity</code> attribute.</p>

    <pre><code class="language-js">try {(function() {
// Function called on failure:
// - `Error` as first argument
// - `bool` whether it was a fallback failure
var loadErrCb = window.resourceLoadError;

// Internal way to recognize fallback loads
var retryAttr = 'data-sri-fallback-retry';

// HTML attribute used to describe fallback URL
var fbAttr = 'data-sri-fallback';

var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
// Browsers without MO won't support SRI
if(MutationObserver) {
  new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) { mutation.addedNodes.forEach(processNode); });
  }).observe(document, { childList: true, subtree: true });
}

var processNode = function(node) {
  var tagName = (node.tagName || '').toLowerCase();
  var tagAttribute = null;
  if (
    (
      (tagName === 'link' && node.href && (tagAttribute = 'href'))
      || (tagName === 'script' && node.src && (tagAttribute = 'src'))
    ) && node.integrity && !node.getAttribute(retryAttr)
  ) {
    node.onerror = function(e) {
      if (node.getAttribute(fbAttr)) {
        var fb = document.createElement(node.tagName);
        fb.integrity = node.integrity;
        fb.crossOrigin = node.crossOrigin;
        fb.rel = node.rel;
        fb.setAttribute(retryAttr, '1');
        fb.type = node.type;
        fb[tagAttribute] = node.getAttribute(fbAttr);
        fb.onerror = function(e) {
          loadErrCb(e, true);
        };
        document.head.appendChild(fb);
      } else {
        loadErrCb(e, false);
      }
    };
  }
};
})();} catch(e) {console.error(e)};
    </code></pre>

    <p>And its minified version <em>(~400b gzipped)</em>, also on <code><a href="">npm - </a></code></p>

    <pre><code class="language-js">try{(function(){var d=window.resourceLoadError,c=window.MutationObserver||window.WebKitMutationObserver;c&&(new c(function(a){a.forEach(function(a){a.addedNodes.forEach(f)})})).observe(document,{childList:!0,subtree:!0});var f=function(a){var c=(a.tagName||"").toLowerCase(),e=null;("link"===c&&a.href&&(e="href")||"script"===c&&a.src&&(e="src"))&&a.integrity&&!a.getAttribute("data-sri-fallback-retry")&&(a.onerror=function(b){a.getAttribute("data-sri-fallback")?(b=document.createElement(a.tagName),
b.integrity=a.integrity,b.crossOrigin=a.crossOrigin,b.rel=a.rel,b.setAttribute("data-sri-fallback-retry","1"),b.type=a.type,b[e]=a.getAttribute("data-sri-fallback"),b.onerror=function(a){d(a,!0)},document.head.appendChild(b)):d(b,!1)})}})()}catch(d){console.error(d)};</code></pre>

    <h2>Other considerations</h2>
    Have a reason to use it.
    You should use HTTPS and send no-transform https://www.w3.org/TR/SRI/#proxies
    Using this together with <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">CSP</a> is a good idea.

    <h2>Thanks to</h2>
    <ul>
      <li><a href="https://github.com/cyph/sri-fallback">sri-fallback</a></li>
      <li><a href="http://stackoverflow.com/a/3219767/3484158">This SO answer</a></li>
    </ul>
  </main>
  <script src="prism-min.js"></script>
</body>
</html>
